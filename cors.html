<!DOCTYPE html>
<html>
<head></head>
<body>

<h1>Pdf-to-text webapp</h1>
<ol type="A">
	<li>Input a .pdf file url. Type in the url to view a pdf, for example:
		<ul>
			<li>https://raw.githubusercontent.com/CodeSolutions2/pdf_to_text_webapp/main/document.pdf</li>
			<li>https://raw.githubusercontent.com/CodeSolutions2/pdf_to_text_webapp/main/document_imagepdf.pdf</li>
			<li>https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf</li>
		</ul>
	</li>
	<li>View the extracted text from pdf file.</li>
	<li>View PDF.</li>
</ol>
  
<!-- ---------------------------------------- -->
<!-- View two split window -->
<div align="left">
<table style='text-align: left; width: 500px; display:block'>
<tr>

<th id="pdf_viewer_input">

<h3>[Step 0] Input a .pdf file url.</h3>
<input id="file_download_url" type="text" value="" placeholder="file_download_url" rows="10" cols="100" style="display:block; text-align: left; width: 600px;">
<br>
<button id="show_pdf_wo_CORS" onclick="show_pdf_wo_CORS()">[Step 0] show_pdf_wo_CORS</button>
<br>
<button id="show_pdf_w_CORS_GithubURL" onclick="show_pdf_w_CORS_GithubURL()">[Step 0] show_pdf_w_CORS_GithubURL</button>
<br>
<button id="show_pdf_w_CORS_nonGithubURL" onclick="show_pdf_w_CORS_nonGithubURL()">[Step 0] show_pdf_w_CORS_nonGithubURL</button>
<br>

<button id="regular_fetch" onclick="regular_fetch()">regular_fetch</button>
<br>
<button id="proxy_call_with_apply_way0" onclick="proxy_call_with_apply_way0()">proxy_call_with_apply_way0</button>
	
<br>
	
<div id="notification"></div>
<div id="error"></div>
<br>
  
<h3>[Step 1] View the extracted text from pdf file.</h3>
<textarea id="selected_text" rows="35" cols="100" placeholder="Selected Text" style="display:block" width:100px; height: 200px;></textarea>
</th>
	
<!-- ---------------------------------------- -->

<th id="pdf_viewer_output">
<h3>[Step 2] View PDF.</h3>
</th>
	
</tr>
</table>
</div>  
<!-- ---------------------------------------- -->


<!-- ---------------------------------------- -->
<!-- CSS -->
<style>
div { padding: 10px; display:block; font-family:courier; font-size:15px; height:300px; }
	
div#notification { position: relative; color: #3236a8; }
div#error { position: relative; color: #bd1f17; }

table {vertical-align: top; border-collapse: collapse; position: relative; z-index: 0; border: 0px solid black;}

tr {vertical-align: top; border: 0px solid black; padding: 30px 30px; }

th, td {vertical-align: top; border: 0px solid black; padding: 10px; }
th#pdf_viewer_input {width: 100%; }
th#pdf_viewer_output {width: 100%; }

object#pdf_object_element {position: absolute; vertical-align: top; top: 200; z-index: 200; }
</style>

	  
<!-- --------------------------------------------------- -->


<script>

const repoOwner = 'CodeSolutions2';
const repoName = 'pdf_to_text_webapp';


	

// ----------------------------------------------------
// Step 0
// ----------------------------------------------------
// Show pdf without CORS
async function show_pdf_wo_CORS() {

  await read_text_from_pdf();
  
  try {
  	// without CORS: name of file
	console.log("file_download_url: ", document.getElementById("file_download_url").value);
	  
  	let file_download_url_name = document.getElementById("file_download_url").value.split('/').pop();
  	console.log("file_download_name: ", file_download_url_name);
  
  	await show_pdf_on_page(file_download_url_name);
	  
  } catch (error){
    document.getElementById("error").innerText = error;
  }
  
}


// ----------------------------------------------------


// Show pdf WITH CORS
async function show_pdf_w_CORS_GithubURL() {
  
  await read_text_from_pdf();

    // Try 3: Download a file blob from the original url
    await fetch(document.getElementById("file_download_url").value)
			.then(response => response.blob())
			.then(async function(blob_object) {

	// Try 3: test if it downloads something
	console.log('blob_object: ', blob_object);  // blob {size: 8925, type: "application/octet-stream"}
	return new File ([blob_object], "file_download", {type: "application/pdf"});
	})
	.then(async function(file_blob_object) {
		console.log('file_blob_object: ', file_blob_object);
		
		let github_url_of_externally_downloaded_data = URL.createObjectURL(file_blob_object);
		console.log('github_url_of_externally_downloaded_data: ', github_url_of_externally_downloaded_data);
		await show_pdf_on_page(github_url_of_externally_downloaded_data);
	})
    
}
	
// ----------------------------------------------------

// Show pdf WITH CORS
async function show_pdf_w_CORS_nonGithubURL() {

	await read_text_from_pdf();

	

	
	// Try 1 : mal-formed XMLHttpRequest
	// var xhr = new XMLHttpRequest();
	// xhr.open('GET', document.getElementById("file_download_url").value);
	// xhr.responseType = 'blob';
	// xhr.onload = function (e) {
	// 	console.log(xhr.response);
	// 	if (this.status == 200) {
	// 		var blob_object = this.response;
	// 		console.log('blob_object: ', blob_object);
	// 	}
	// };
	// xhr.send();
	// TypeError: NetworkError when attempting to fetch resource.

	
	// Try 2: what I did before that obtained an XMLHttpRequest response for CORS
	// await function2call_the_callback(function2run_with_callback_return, document.getElementById("file_download_url").value)
	// 	.then(function(result) { 
	//		console.log("result: ", result); 
	//	});

	
	// Try 3: use pdf.js
	// Asynchronous download of PDF
	// module.pdfjsLib.getDocument(document.getElementById("file_download_url").value)
	// 	.then(response => response)
	// 	.then(async function(pdfDoc) { 
	// 		console.log("pdfDoc: ", pdfDoc);
	// 		// return pdf_blob_object; 
	// 	})
	// 	.catch(error => { console.log(error); });
  
	
}

async function regular_fetch() {
	
	// Try 0: download the file from another domain and then save it to the current domain
	// Problem: I can not even get the blob url because of CORS error

	var url = document.getElementById("file_download_url").value;
	var headers = {
		"Content-Type": "application/json",
		"Connection": "keep-alive",
		"Access-Control-Allow-Origin": "*",
	};
	
	var options = {
		method : 'GET',
		mode: 'cors',
		cache: "no-cache",
		headers: new Headers(headers),
		redirect: "follow"
	};
	
	await fetch(url, options)
		.then(response => response.blob())
		.then(async function(blob_object) { 
			console.log('blob_object: ', blob_object);
			// return URL.createObjectURL(blob_object); 
		})
		.catch(error => console.error(error));
	//  		.then(async function(blob_object) {
	// console.log('blob_object: ', blob_object);  // blob {size: 8925, type: "application/octet-stream"}
	// return new File ([blob_object], "file_download", {type: "application/pdf"});
	// })
	// .then(async function(file_blob_object) {
	// 	console.log('file_blob_object: ', file_blob_object);
	// 	let github_url_of_externally_downloaded_data = URL.createObjectURL(file_blob_object);
	// 	console.log('github_url_of_externally_downloaded_data: ', github_url_of_externally_downloaded_data);
	// 	await show_pdf_on_page(github_url_of_externally_downloaded_data);
	// })


	// Response Header
	// HTTP/2 404 
	// server: GitHub.com
	// content-type: text/html; charset=utf-8
	// permissions-policy: interest-cohort=()
	// etag: W/"667dfbb1-239b"
	// content-security-policy: default-src 'none'; style-src 'unsafe-inline'; img-src data:; connect-src 'self'
	// content-encoding: gzip
	// x-github-request-id: 749E:307D28:B3AC0F:B7AC4D:6683C1C0
	// accept-ranges: bytes
	// age: 0
	// date: Tue, 02 Jul 2024 09:00:48 GMT
	// via: 1.1 varnish
	// x-served-by: cache-par-lfpg1960046-PAR
	// x-cache: MISS
	// x-cache-hits: 0
	// x-timer: S1719910848.380074,VS0,VE106
	// vary: Accept-Encoding
	// x-fastly-request-id: 33e1eda13247e3daff9057c8682c75a6453bdfcb
	// content-length: 5142
	// X-Firefox-Spdy: h2

	// Request Header
	// GET /favicon.ico HTTP/2
	// Host: codesolutions2.github.io
	// User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:120.0) Gecko/20100101 Firefox/120.0
	// Accept: image/avif,image/webp,*/*
	// Accept-Language: en-US,en;q=0.5
	// Accept-Encoding: gzip, deflate, br
	// DNT: 1
	// Sec-GPC: 1
	// Connection: keep-alive
	// Referer: https://codesolutions2.github.io/pdf_to_text_webapp/cors.html
	// Sec-Fetch-Dest: image
	// Sec-Fetch-Mode: no-cors
	// Sec-Fetch-Site: same-origin

}


async function proxy_call_with_apply_way0() {

	// Parameters to influence Response Header
	// The `handler` object defines a `apply` method that intercepts the `fetch` function calls and adds the "Access-Control-Allow-Origin" header with a value of "*" to the request options. The `new Proxy(fetch, handler)` creates a proxied version of the `fetch` function that applies the defined handler.

	// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers
	
	const handler = {
		apply: function(target, thisArg, args) {
			// One needs to re-define the input arguments of the handler because a constant variable is used as a function (ie: await proxy3(url, options))
			const [url, options] = args;
			if (options && options.headers) {
				options.headers['Access-Control-Allow-Origin'] = '*';
				options.headers['Access-Control-Allow-Credentials'] = false;
				options.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE';
				// options.headers['Access-Control-Allow-Headers'] = 'Origin, X-Requested-With, Content-Type, Accept';
				options.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization';
				options.headers['Access-Control-Max-Age'] = 0;
			} else {
				args[1] = {
					headers: { 
						'Access-Control-Allow-Origin': '*',
						'Access-Control-Allow-Credentials': false,
						'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE',
						'Access-Control-Allow-Headers': 'Content-Type, Authorization',
						'Access-Control-Max-Age': 0
					}
				};
	 		}
	 		console.log('args: ', args);
	 		return Reflect.apply(target, thisArg, args);
		}
	};

	
	var url = document.getElementById("file_download_url").value;

	// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers
	// "Sec-Fetch-Mode": "cors", // Indicates the request's mode to a server: cors, navigate, no-cors, same-origin, websocket

	// Sec-Fetch-User:  ?0 = false, ?1 = true
	// Sec-Fetch-Dest: audio, audioworklet, document, embed, empty, font, image, manifest, object, paintworklet, report, script, serviceworker, sharedworker, style, track, video, worker, and xslt
	// "Sec-Fetch-Site": "cross-site", // cross-site, same-origin, same-site, none
	// 'Cache-Control': 'max-age=0' // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security?utm_source=mozilla&utm_medium=devtools-netmonitor&utm_campaign=default - this allows one to change the preflight request, other wise the preflight request settings are set for a year
	var headers = {
		"Content-Type": "application/json",
		//"Referer": document.getElementById("file_download_url").value,
		//"Origin": "https://codesolutions2.github.io",
		//'Cache-Control': 'max-age=0',
		//"Connection": "keep-alive",
		//"Sec-Fetch-Dest": "empty",
		//"Sec-Fetch-Mode": "cors", 
		//"Sec-Fetch-Site": "cross-site",
		//"Sec-Fetch-User": "?1",
		//"User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:120.0) Gecko/20100101 Firefox/120.0",
		//"Access-Control-Request-Method": 'GET',
		//"Access-Control-Request-Headers": 'content-type,x-pingother'
	};
	var options = {
		//method : 'GET',
		//mode: 'cors',
		//cache: "no-cache",
		crossorigin: 'anonymous',
		headers: headers,
		//redirect: "follow"
	};

	// Call the constant variable proxy3 as a function to resolve the promise correctly
	const proxy3 = new Proxy(fetch, handler);
	await proxy3(url, options)
		.then(response => response.blob())
		.then(async function(blob_object) { 
			console.log('blob_object: ', blob_object);
			// return URL.createObjectURL(blob_object); 
		})
		.catch(error => console.error(error));

	// Proxy sturcture works! 
	// Calls the function WITHOUT input variables to assign a proxy definition to a constant variable. 
	// The constant variable is called as a function, where it resolves promises. 

	// Need to solve the next error:
	// (Reason: CORS request did not succeed). Status code: (null).
	// (Reason: CORS preflight response did not succeed). Status code: 403
	// Solution: add more headers that it may be missing - received the same error

	// Response Header
	// HTTP/2 403 
	// cache-control: no-cache
	// content-type: text/html; charset=utf-8
	// strict-transport-security: max-age=31536000
	// x-content-type-options: nosniff
	// x-frame-options: deny
	// x-xss-protection: 0
	// content-security-policy: default-src 'none'; style-src 'unsafe-inline'; img-src data:;
	// accept-ranges: bytes
	// date: Tue, 02 Jul 2024 10:43:41 GMT
	// via: 1.1 varnish
	// x-served-by: cache-par-lfpg1960050-PAR
	// x-cache: MISS
	// x-cache-hits: 0
	// x-timer: S1719917021.126861,VS0,VE9
	// access-control-allow-origin: *
	// cross-origin-resource-policy: cross-origin
	// x-fastly-request-id: 9aa24a414b4381b89251b33b70f7b64573ec8516
	// expires: Tue, 02 Jul 2024 10:48:41 GMT
	// vary: Authorization,Accept-Encoding
	// X-Firefox-Spdy: h2

	// Request Header
	// OPTIONS /CodeSolutions2/pdf_to_text_webapp/main/document.pdf HTTP/2
	// Host: raw.githubusercontent.com
	// User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:120.0) Gecko/20100101 Firefox/120.0
	// Accept: */*
	// Accept-Language: en-US,en;q=0.5
	// Accept-Encoding: gzip, deflate, br
	// Access-Control-Request-Method: GET
	// Access-Control-Request-Headers: content-type
	// Referer: https://codesolutions2.github.io/
	// Origin: https://codesolutions2.github.io
	// DNT: 1
	// Sec-GPC: 1
	// Connection: keep-alive
	// Sec-Fetch-Dest: empty  // audio (<audio>), audioworklet (audioWorklet.addModule(), document, embed, frame, image, object, video)
	// Sec-Fetch-Mode: cors
	// Sec-Fetch-Site: cross-site

	// Is Sec-Fetch-Dest: empty OK? it means that a specific destination element is not specified because on performs fetch()
	// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Dest
	
	// Try to use the set method, maybe the apply function does not set the values
}



	

// ----------------------------------------------------


async function show_pdf_on_page(file_download_url_name) {

 	var objectElement = document.createElement('object');
  	objectElement.setAttribute("id", "pdf_object_element");
  	objectElement.setAttribute("type", "application/pdf");
  	objectElement.setAttribute("width", 800);
  	objectElement.setAttribute("height", 1200);
  	objectElement.setAttribute("data", file_download_url_name);
  	document.getElementById('pdf_viewer_output').appendChild(objectElement);
}
  
  
	

// ----------------------------------------------------
// Step 1
// ----------------------------------------------------
	
// Way 0: try reading text from the pdf
// WORKS
async function read_text_from_pdf() {

	await GET_text_from_file_wo_auth_GitHub_RESTAPI_directurl(document.getElementById("file_download_url").value)
		.then(async function(text_out) {
			// console.log('text_out: ', text_out);
      document.getElementById('selected_text').innerHTML = text_out;
      
		});

}

	
	
async function GET_text_from_file_wo_auth_GitHub_RESTAPI_directurl(file_download_url) {

	return await fetch(file_download_url)
		.then(res => res.text())
		.then(str_data => { 
			// console.log('str_data: ', str_data); 
			
			// try to decode characters from [stream to endstream]
			// let valstofind = /stream(.*?)endstream/g;
			// var matches = valstofind.exec(str_data);
			// console.log('matches: ', matches);

			// var one_match_string = str_data.match(valstofind);
			// console.log('one_match_string: ', one_match_string);
			// let data_decoded = atob(one_match_string);
			// console.log('data_decoded:', data_decoded);

			// Try 0
			const charCodes = [777, 610, 500, 277, 389, 250, 443, 500, 500, 333, 500, 443, 500, 777, 443, 500, 277, 250];
			const text = charCodes.map(code => String.fromCharCode(code)).join('');
			console.log('text: ', text);
			// text:  ̉ɢǴĕƅúƻǴǴōǴƻǴ̉ƻǴĕú

			// Try 1
			const uint8Array_out = new Uint8Array(charCodes);
			// console.log('uint8Array_out:', uint8Array_out);
			
			// Convert UTF-8 array [non-fixed length array] to text
			var text1 = new TextDecoder().decode(uint8Array_out);
			console.log('text1: ', text1);


			
			
			return str_data;
		})
		.catch(error => { console.log(error); });
}
  
// ----------------------------------------------------
  
	
// ----------------------------------------------------

// ----------------------------------------------------


// ----------------------------------------------------


  
// ----------------------------------------------------
	


  
</script>

  </body>
</html>
